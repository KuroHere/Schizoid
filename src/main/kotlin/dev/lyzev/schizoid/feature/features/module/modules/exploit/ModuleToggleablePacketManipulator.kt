/*
 * Copyright (c) 2024. Schizoid
 * All rights reserved.
 */

package dev.lyzev.schizoid.feature.features.module.modules.exploit

import dev.lyzev.api.events.*
import dev.lyzev.api.setting.settings.*
import dev.lyzev.schizoid.feature.features.module.ModuleToggleable
import net.minecraft.network.NetworkState
import net.minecraft.network.packet.Packet
import dev.lyzev.api.settings.Setting.Companion.neq
import net.minecraft.network.listener.PacketListener
import net.minecraft.text.Text
import java.util.concurrent.CopyOnWriteArrayList

// TODO: Not finished!!! DO NOT USE!!!
object ModuleToggleablePacketManipulator :
    ModuleToggleable("Packet Manipulator", "Manipulates S2C and C2S packets.", category = Category.EXPLOIT), EventListener {

    val type by multiOption("Type", "Packets to manipulate.", EventPacket.Type.entries)

    val mode by option("Mode", "The mode of the packet manipulation.", Mode.DELAY, Mode.entries)

    private var packets = CopyOnWriteArrayList<Triple<Packet<*>, EventPacket.Type, Long>>()

    override fun onEnable() {
        type.firstOrNull { it.second } ?: sendChatMessage(Text.of("Please select a packet type."))
        sendChatMessage(Text.of("Not finished!!! DO NOT USE!!!"))
        toggle()
    }

    override fun onDisable() {
        for (packet in packets) {
            if (packet.second == EventPacket.Type.S2C)
                try {
                    @Suppress("UNCHECKED_CAST")
                    (packet.first as Packet<PacketListener>).apply(mc.networkHandler!!.connection.packetListener)
                } catch (ignored: Exception) {
                }
            else
                mc.networkHandler?.sendPacket(packet.first)
            packets.remove(packet)
        }
        packets.clear()
    }

    override val shouldHandleEvents: Boolean
        get() = isEnabled && mc.networkHandler != null && type.firstOrNull { it.second } != null

    init {
        on<EventPacket>(Event.Priority.LOWEST) { event ->
            if (event.isCancelled) return@on
            if (mc.networkHandler?.state != NetworkState.PLAY && mc.networkHandler?.state != NetworkState.CONFIGURATION) {
                packets.clear()
                return@on
            }
            if ((event.type == EventPacket.Type.S2C && type.elementAt(0).second) || (event.type == EventPacket.Type.C2S && type.elementAt(1).second)) {
                packets.add(Triple(event.packet, event.type, System.currentTimeMillis()))
                event.isCancelled = true
            }
        }
    }

    enum class Mode(override val key: String) : OptionEnum, EventListener {
        STOP("Stop") {

            override val shouldHandleEvents: Boolean
                get() = isEnabled && mode == this
        },
        DELAY("Delay") {

            val delay by slider("Delay", "The delay of the packet manipulation.", 1000, 0, 5000, "ms", hide = ::mode neq this)

            override val shouldHandleEvents: Boolean
                get() = isEnabled && mode == this && mc.networkHandler != null

            init {
                on<EventSwapBuffers> {
                    if (!mc.networkHandler!!.connection!!.isOpen) {
                        packets.clear()
                        return@on
                    }
                    for (packet in packets) {
                        if (System.currentTimeMillis() - packet.third >= delay) {
                            if (packet.second == EventPacket.Type.S2C)
                                try {
                                    @Suppress("UNCHECKED_CAST")
                                    (packet.first as Packet<PacketListener>).apply(mc.networkHandler!!.connection.packetListener)
                                } catch (ignored: Exception) {
                                }
                            else
                                mc.networkHandler?.sendPacket(packet.first) // TODO: Send without calling EventPacket because this will cause an infinite loop
                            packets.remove(packet)
                        }
                    }
                }
            }
        },

    }
}
